#lang scribble/book

@(require "../lib/redex-rewrite.rkt"
          "../lib/util.rkt"
          "../lib/proofs.rkt"
          "../lib/proof-extras.rkt"
          "../lib/rule-figures.rkt"
          "../lib/cite.rkt"
          "../lib/circuit-diagrams.rkt"
          scriblib/figure
          pict)

@title[#:tag "final" #:style paper-title-style]{Final Thoughts}
@section[#:tag "future"]{Future Work}
@subsection{Extending proofs to multiple instants, and guarding compilation}

Future work may wish to extend the proofs for the
Consistency, Soundness, and Adequacy of the Constructive
Calculus to multiple instants. This should be possible with the current definitions, with
one tweak to the compilation of terms.

This tweak involves the assumption that the compilation
function makes, that @es[GO] and @es[SEL] are mutually
exclusive. The circuits generated by @es[compile]
do not behave properly if this condition is not met: in essence
it is undefined behavior. However this ruins many equities that
should hold, as having both @es[GO] and @es[SEL] true simultaneously
can expose details of the internals of a term that are not observable in
Esterel, but are observable in the circuit.

Consider the equality in @figure-ref["broken-equalites"].
These two programs should be @es[≃^esterel], as the signal
@es[S] can never be emitted in the same instant as the
conditional on it. However consider their circuit
compilations: in the first program there will be a wire
@es[(= S1 (and GO S))]. However in the second one their will
be no @es[S1] wire, therefore it will be taken to be @es[0].
If, in the second cycle, @es[GO] is @es[1], (making it
@es[1] at the same time as @es[SEL]) the wire @es[S1] will
get a @es[1], as both @es[GO] and @es[S] will be @es[1]. But
this differs from the second program! This means that the
two circuits are not @es[≃^circuit], which violates
soundness.

@figure["broken-equalites"
        "An equivalency that should hold"
        (hc-append 15
                   @es[(signal S
                         (seq
                          (present S (emit S1) nothing)
                          (seq pause
                               (emit S))))]
                   @es[≃^esterel]
                   @es[(signal S
                         (seq pause (emit S)))])]

No Esterel context would ever produce a violation like this,
as this only occurs when the outer circuit context violates the
protocol that @es[GO] and @es[SEL] are mutually exclusive.
Therefore we can fix this by wrapping any compilation in a guard
which, if this condition is violated, forces the circuit to have consistent
behavior. Such a wrapper is given in @figure-ref["guard"]. This guard
sets the @es[GO] wire to @es[0] if it is ever @es[1] at the same time as @es[SEL],
preventing the circuit from changing the violation.

@figure["guard"
        "Guarding the top of a circuit to avoid protocol violations"
       (hc-append
        @es[(guard circuit)]
        @es[=]
        guard-pict)]
        

From here we can modify the statement of soundness to:
@proof[#:label "soundness2"
       #:title "Soundness over multiple insants"
       #:type 'theorem
       #:no-proof #t
       #:statement @list{For all @es[p-pure] and @es[q-pure],
        if @es[(CB p-pure)] and
        @es[(≡ p-pure q-pure)],
        then
        @es[(≃^circuit (guard (compile p-pure)) (guard (compile q-pure)))]}]
Which should hold. I believe that this is the only guard necessary. This believe
comes from the proofs I have done so far: Other than proofs involving @es[Can],
the mutual exclusion of @es[GO] and @es[SEL] is the strongest precondition
needed.@note{As we always take @es[SEL] to be @es[0], this condition
is given by the existing preconditions on soundness and adequacy.}
Adequacy must also be extended in a similar manner. However
the new statement of Adequacy must be extended to involve
the inter-instant translation function @es[next-instant].
While I have not developed all of the machinery needed
for this extension, I believe it would not be difficult to do so.


TODO Res Susp Kill guarding (or lack their of)


@subsection[#:tag "future:remove"]{Removing θ from ρ}

I suspect that there is a variant of my calculus which is
both stronger (in the sense that it can prove more things
equal) and does not require the @es[θr] portion of the
environment. The idea behind is this that a @es[θr] can
always be removed by running the existing @rule["emit"] and
@rule["signal"] rules backwards, so why add it in the first
place? Specifically, I believe that the @rule["emit"] and
@rule["is-present"] rules can be replaced with:

@[render-specific-rules2 '(emit is-present)]

In this new system @rule["is-present"] because the rule
sensitive to @es[GO]. It says that we may take the then
branch of an @es[if] when the environment is @es[GO] and
there is an @es[emit] for that signal in a relative
evaluation context. The correctness of this rule can be
validated by the current calculus (modulo the different
environment shape).

The @rule["emit"] rule is where the extra power comes in. It
lets us reshuffle @es[emit]s arbitrarily within evaluation
contexts. This would let us, for example, lift an @es[emit]
out of a @es[seq] so that it would be in a relative
evaluation context with respect to an @es[if]. But it would
also let us move @es[emit]s elsewhere. For example, we could
validate that @es[(≡ (par (emit S) q) (seq (emit S) q))],
which has a slightly simpler circuit because there is not
synchronizer. It would also let the calculus prove
@proof-ref["unprovable-lifting"], which was discussed in
@secref["example"]. The @rule["emit"] rule cannot be proven by the
current calculus, because in enables reasoning about
@es[emit]s when there is no @es[GO].

The definition of @es[Can] would also need to change in this variant of the calculus.
The @es[Can] function would likely still need an @es[θ] argument, therefore @es[Can]
will need to add @es[1]s to @es[θ] somehow. This could likely be done by replicating
the relative evaluation context reasoning from the @rule["is-present"] rule, but it
is not clear to me yet how exactly this would work, and proving it correct is
another thing entirely.

@subsection{Fully Abstract Compilation}

An ambitious future semanticist may with to attempt that the Esterel compiler (augmented
with the @es[guard] procedure) is fully abstract. I believe that the Constructive Calculus
gives the tools to do this.
Specifically, this would look like:
@proof[#:label "fully abstract"
       #:title "Fully Abstract Compilation"
       #:type 'theorem
       #:no-proof #t
       #:statement @list{For all @es[p-pure] and @es[q-pure],
        @es[(≃^esterel p-pure q-pure)]
        if and only if
        @es[(≃^circuit (guard (compile p-pure)) (guard (compile p-pure)))]}]
The reasons that such a proof may be within reach follows from the following chain of reasoning.
First, the definition of @es[≃^circuit] used here is defined by providing
all of the (finite) possible inputs.
Second, The inputs to the circuit can be simulated using Esterel contexts. For example,
if we have one input signal @es[SI], we can simulate all inputs on it using the contexts
@es[(signal SI hole)], @es[(signal SI (par (emit SI) hole))],
and @es[(signal SI (par (present SI (emit SI) nothing) hole))], which correspond to
@es[0], @es[1], and @es[⊥] respectively. Thirds, we know that
the evaluator given by the Constructive Calculus is equivalent to the circuit evaluator
by @proof-ref["comp-ad"]. Therefore if the contexts which simulate the inputs
to the circuit are sufficient to decide contextual equivalence between two Esterel
terms, it must be that the notions of contextual equivalence between Esterel and Circuits
is the same. I believe that these contexts should be enough to decide contextual equivalence
between Esterel terms,
however it is not yet clear to me how a proof of this would proceed.

@section{Conclusion}
