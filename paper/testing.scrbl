#lang scribble/base
@(require "cite.rkt"
          "redex-rewrite.rkt"
          "util.rkt"
          scriblib/figure
          scribble/core
          redex/reduction-semantics
          (prefix-in p: pict))

@(define |Esterel v5| @nonbreaking{Esterel v5})

@title[#:tag "sec:testing"]{Testing}

As we are developing a new semantics for Esterel and Esterel
is a well-established language, a natural concern is whether
our semantics captures Esterel or some other,
subtly different language. In order to mitigate this
concern, we tested our semantics against two Esterel
implementations: @|Esterel\ v5|@~cite[esterel-v5] and
Hiphop@~cite[hiphop], as well as an executable version of
@citet[compiling-esterel]'s COS semantics. Perhaps
unsurprisingly, we also discovered bugs in both of the
implementations during this process (as random testing can
be extremely effective@~cite[csmith]). The remainder of this
section describes the testing process and the bugs discovered.

@section{Testing for conformance}

@(define (itemlistheader . args)
   (element "textsf" (list (element "textbf" args)
                           (element "hspace*" '(".1in")))))

In order to test our model against the existing semantics
and implementations, we had to build some software
libraries: @itemlist[@item{@itemlistheader{Redex COS model} We built a
                      model of the COS semantics in Redex@~cite[redex-book]. The semantics is a
                      faithful model of the COS semantics because it is a
                      rule-for-rule translation of the COS semantics; aside from a
                      few syntactic differences (notably more parentheses), it
                      mirrors @citet[compiling-esterel]'s model exactly, enabling
                      us to simulate the behavior of the semantics on any example
                      program.}

                     @item{@itemlistheader{Redex calculus model} Our
                      calculus is implemented in Redex; the rules shown in all of
                      the figures are generated automatically from the Redex
                      source code, and the Redex model also enables us to explore
                      the reduction of any example program.}

                     @item{@itemlistheader{Agda/Redex bridge} We built
                      a library that can translate the reduction sequences
                      generated by Redex into proofs in Agda, ensuring that the specific,
                      concrete terms which reduce in Redex also reduce the same
                      way in Agda. This process accepts a specific term and a
                      reduction sequence. It produces a proof, which then is
                      submitted to the Agda compiler for verification.}

                     @item{@itemlistheader{Redex/Hiphop bridge} We
                      built a library that can translate Redex expressions into
                      HipHop programs and then evaluate them. We also built a
                      translator for a subset of HipHop programs that can
                      translate them into Redex so they can be checked against the
                      calculus and the COS model. This translator does not accept
                      all HipHop programs, because HipHop programs embed
                      JavaScript code and our model cannot evaluate the
                      JavaScript.}

                     @item{@itemlistheader{Redex/@|Esterel\ v5| bridge}
                      We also built a translator that produces @|Esterel\ v5| programs
                      from Redex terms in the COS model and in our calculus.}]

Using these libraries we can now test all four
implementations of Esterel (the COS semantics, the @|Esterel\ v5|
compiler, HipHop, and our calculus) against each other.

There is one subtle point about testing our calculus.
Because it is a calculus, we
need an algorithm that can determine which of the many
possible reductions we should take in order to find an
effective path to a @es[complete] state (if one exists). To do
this, we identified a subset of the possible reductions in a
way that acts like an standard reduction, guaranteeing that we
find a @es[complete] if the program is constructive, and that reduction gets stuck if it is not.
This reduction relation is
given in @figure-ref["fig:standard"] with some supplementary
definitions given in @figure-ref["fig:standard-aux"]; it is explained
briefly in @secref["sec:stdred"]. We use
this reduction relation to guide the calculus, verifying
that each step in the standard reduction is also possible in
the calculus. There are no proofs about our standard
reduction but we use it only to test our calculus against
other implementations, as described in this section.

These libraries give us the ability to, given an Esterel
program, determine if it produces the same signals across
multiple instants. But we also need a source of Esterel
programs to test. For that purpose, we used two approaches.

First, we took the HipHop test suite, which consists of 130
HipHop programs. Of those, four use @tt{pre}, a construct
that is not in Kernel Esterel, and were excluded from our tests. An
additional 84 use JavaScript in some non-trivial way, and therefore could also not be
run in our model. Our calculus produces the same results on the remaining 42 program
as HipHop.

The translation of the HipHop tests into our model produces
programs that have a large number of signals, which causes
problems for the process that finds reductions in the
calculus. In short, the problem is that the exponential
behavior in @es[Can] triggers significant performance
problems in the calculus, enough so that running these tests
appears not to be feasible. To mitigate this issue, we
disabled the exponential behavior of @es[Can] (by
eliminating the first case in @es[Can-Î¸] and the first
@es[signal] case) and then were able to use the standard
reduction to simulate the calculus successfully, and got the
same results as the HipHop implementation.

@(require racket/runtime-path racket/system racket/port racket/string racket/format)
@(define-runtime-path loc "../final-tests/logs/")
@(define test-count*
   (string->number
    (string-trim
     (call-with-output-string
      (lambda (o)
        (parameterize ([current-directory loc]
                       [current-output-port o])
          (system
           "racket -e \"(+ `for x in *ternal*; do grep \"running test\" $x | tail -1; done | awk '{ print $3 }'` )\"")
          ))))))

@(unless (number? test-count*) (error 'arg "expected a test count, got ~a" test-count))

@(define test-count (* 100000 (floor (/ test-count* 100000))))

Second, we used Redex's capability to generate random
Esterel expressions and run them in all of the
implementations to see if they agree. We have discovered
(and fixed) errors in our calculus using this method, and we
currently have no known bugs. We have run over @(~a test-count)
random tests and they still do periodically find
counterexamples, but they find only known bugs in the
implementations.

@; TODO can we pull this number directly from the long on build?

This random testing process proved invaluable in debugging
the calculus, catching several errors that proved difficult
to find even through building the proofs in
Agda. For example, late in the development process, the
random tester found that an old version of the
@rule["shared"] rule was incorrect. The old version
initialized the shared variables status to @es[new], but
the COS specifies that the initial status is
@es[old]. Over a year of debugging, hand inspection, and
theorem proving had failed what was, essentially, a typo in
early versions of the calculus.

@section{Bugs Discovered}

@right-figure[#:lines 7 #:caption "A Bug Found in the Esterel v5 Compiler" #:tag "ex:vfivebug"]{
@(term-let
  ([e_0 (term (+ 0))]
   [e_1 (term (+ 1))]
   [e_outer (term (+ s-outer))])
  @esblock[(shared s-outer := e_0
             (seq (shared s-inner := e_outer
                    nothing)
                  (<= s-outer e_1)))
           #:run-instants
           (list '())
           #f
           (list)])}

During the process of validating our calculus, we discovered
four bugs in HipHop and one bug in the @|Esterel\ v5| compiler.
All of the bugs have been confirmed by the authors of the
systems. All but one of the HipHop bugs have been fixed.

The bug in @|Esterel\ v5| is exhibited by a translation
of the program in @figure-ref["ex:vfivebug"],
where @es[e_0] evaluates to @es[0],
@es[e_1] evaluates to @es[1], and @es[e_outer] refers to
@es[s-outer].

This program is non-constructive and it gets stuck in our both our
calculus and the COS semantics; it cannot reduce the inner @es[shared] because the
initialization of the variable depends on @es[s-outer], but
@es[s-outer] cannot be read because there is a write
pending. The @|Esterel\ v5| compiler runs the program,
incorrectly setting @es[s-inner] to @es[0].

This program also demonstrates one of the bugs we found in HipHop. Of the other three bugs,
one of them was an internal error, crashing HipHop on this program
@es[(trap (suspend (exit 0) S1))]. The next bug was
triggered by this expression @es[(suspend nothing S1)], and produced an error
in terms of HipHop's host language, Javascript's, @tt{undefined} value.

@right-figure[#:wide? #t #:lines 9 #:caption "A Bug Found in HipHop" #:tag "ex:lastbug"]{
@esblock[(signal S-outer
           (signal S-inner
             (seq
               (present S-outer nothing nothing)
               (present S-inner
                        (emit S-outer)
                        nothing))))]
 }

The final bug is exhibited by the program in @figure-ref["ex:lastbug"].
Both in our calculus and in the COS semantics, the potential
function can determine that @es[S-inner] cannot be emitted,
and that therefore @es[S-outer] cannot be emitted. Therefore
the program is constructive, both signals are @es[absent],
and the program reduces to @es[nothing]. However this
program appeared to be non-constructive to HipHop. As of
this writing, the bug is being actively worked on by the
HipHop developers.
